#30
sassを使わずcss+CoffeeUIクラスを作ることを考慮
次回プロジェクトより

それとは別にwatcherの統合が必要
watchは基本的に、起動時に１回のみ#（メモリリークが解消されるまで）
reloadイベントも同様に絡める

#19
http://memo.yomukaku.net/entries/uuptBYV
child_process.execを使い、連携する。
javaや多言語との繋がりでもこれは多用すると思われる。

#2015/04/11
coffeeのみを渡していく方針 →　再却下
パッケージ化をなるべくやっていくが、開発環境を更新する。
Atom-Shell-Sample
	名前考慮したが、間違えたままとりあえず開発。いずれcloneし、正式名称を考える。


#2015/03/
クロスレンダラーアプリを作る
	必要な部品
		発火イベント
			埋め込みhtml側
				→ブラウザのみに送る
					ipcから、"send_browser"を指定し、データを送る
				→別レンダラーに送りたい場合
					ipcから、"send_(renderer)_via_browser"を指定し、データを送る
			メインブラウザ
				→各ブラウザへ送りたい場合
					BrowserWindowから、"send_renderer"を指定し、メッセージを送る
			外部サイトを表示するレンダラー
				起動時にブラウザがスクリプトコードを埋め込む
					→ipcを含んだ構文を埋め込む グローバルオブジェクトとしてipcを含める、(onEventは、双方向返答待ちイベントを含む場合に必須)
					→ブラウザのみに送る
						→特定のイベントハンドラにより、ipcを実行し、"send_browser"を指定し、データを送る
					→別レンダラーへ送る
						→特定のイベントハンドラにより、ipcを実行し、"send_(renderer)_via_browser"を指定し、データを送る
		要構想
			発火イベントの指定方法
				channelを個別に分ける方法
				channelを一括りにし、ブラウザもしくはレンダラ側で判別させる方法
					仮採用、F4再起動が減る、ブラウザの更新だけで住むことが多い
					→それならば、コード埋め込み自体も、埋め込みhtmlで実装する？？？
					メリット
						ファイル更新のみで実行可能、コンソールも見れる。;/この機能は欲しい。/
					デメリット
						２つのレンダラーが、別々のサイトであった場合、そもそもがやりにくくなる。
							→元々が、ファイル更新再起動が難しい物である
					両方達成が基本
					1
			２つのレンダラ支配から、３つ以上のレンダラを支配する可能性がある
				要対応
			Browser側のclass拡張
			発火イベントの名前
				rendererとbrowserをどのような名前でいくか
		#
		1
複数プロジェクトを持つSampleAppを作る
	#classes
	New - CrossRenderer - AtomApp
					↓
				CrossRenderer派生
	#main.coffee
	if 最上位
		...
	else 最下位
		...
	#
